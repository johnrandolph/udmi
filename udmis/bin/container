#!/bin/bash -e

ROOT=$(dirname $0)/..
cd $ROOT
DROOT=.

function die {
    echo >&2 "$*"
    exit 1
}

function usage {
    echo >&2 Error: $*
    echo >&2 Usage: $0 { build, shell, run, push, deploy, status, logs, stop }
    echo >&2 Project: $PROJECT
    exit 1
}

function verify_docker_credhelpers {
  local registry="$1"
  local out=$(jq .credHelpers\[\"${registry}\"\] $HOME/.docker/config.json)
  [[ "$out" = "\"gcloud\"" ]]
  return $?
}

function verify_docker_auths {
  local registry="$1"
  local out=$(jq .auths\[\"${registry}\"\]\[\"auth\"\] $HOME/.docker/config.json)
  [[ -n "$out" ]]
  return $?
}

function alter_jar {
  echo alter_jar: not doing this strategy
  return 0
  rm -rf /tmp/xxxx
  mkdir /tmp/xxxx
  unzip -q build/libs/udmis-1.0-SNAPSHOT-all.jar -d /tmp/xxxx
  rm /tmp/xxxx/META-INF/native/libio_grpc_netty_shaded_netty_*.so
  rm build/libs/udmis-1.0-SNAPSHOT-all.jar
  local d="$PWD"
  cd /tmp/xxxx
  zip -q -r "${d}/build/libs/udmis-1.0-SNAPSHOT-all.jar" .
  cd "$d"
}

PROJECT=$(gcloud config get project)
CREGISTRY=gcr.io
REPOSITORY="${CREGISTRY}/${PROJECT}"
IMAGE=udmis
BUILDIMAGE=buildudmis

cmd=$1
shift || usage missing command

verify_docker_credhelpers $CREGISTRY || die "No docker credRegistry, consider running:  gcloud auth configure-docker"
verify_docker_auths $CREGISTRY || die "No docker auths, consider running:  gcloud auth print-access-token | docker login -u oauth2accesstoken --password-stdin https://${CREGISTRY}"

current_user=$USER@$HOSTNAME
current_time=`date --utc --iso=seconds`
version=`git describe --dirty`
funchash=`git log -n 1 --oneline -- src/ | awk '{print $1}'`
funccount=`git diff --name-only -- src/ | wc -l`
if [[ $funccount != 0 ]]; then
    funcdirty=-dirty
fi
funcver=`git describe $funchash`$funcdirty

RUNARGS="--rm -ti -v $PWD/etc:/udmi -v $HOME/.config:/root/.config --tmpfs /tmp"

if [[ $cmd == build ]]; then
    rm -rf var
    mkdir -p var
    cat <<EOF > var/deployed_version.json
{
  "udmi_version": "$version",
  "udmi_functions": "$funcver",
  "built_at": "$current_time",
  "built_by": "$current_user"
}
EOF
    cat var/deployed_version.json
    docker build -f Dockerfile.udmis -t $IMAGE $DROOT
elif [[ $cmd == buildimage ]]; then
    docker build -f Dockerfile.udmis.build -t $BUILDIMAGE $DROOT
elif [[ $cmd == buildrun ]]; then
    # Do something here to either keep container running or keep fs
    rm -rf $PWD/dockerbuild && mkdir $PWD/dockerbuild
    docker run --name buildrun \
      $RUNARGS -v $PWD/dockerbuild:/opt \
      $BUILDIMAGE
elif [[ $cmd == buildshell ]]; then
    docker run $RUNARGS -v $PWD/dockerbuild:/opt $BUILDIMAGE bash
elif [[ $cmd == run ]]; then
    docker run $RUNARGS $IMAGE
elif [[ $cmd == shell ]]; then
    docker run $RUNARGS $IMAGE bash
elif [[ $cmd == push ]]; then
    docker tag $IMAGE $REPOSITORY/$IMAGE
    docker push $REPOSITORY/$IMAGE
    sed -e "s/@PROJECT@/$PROJECT/" < k8s_pod.yaml > var/k8s_pod.yaml
    echo Updated var/k8s_pod.yaml for deployment.
elif [[ $cmd == deploy ]]; then
    kubectl delete pod/udmi-test-pod || true
    kubectl apply -f var/k8s_pod.yaml
elif [[ $cmd == status ]]; then
    kubectl describe pods udmi-test-pod
elif [[ $cmd == logs ]]; then
    kubectl logs udmi-test-pod
elif [[ $cmd == stop ]]; then
    kubectl delete pod/udmi-test-pod
else
    echo Unknown command $cmd
    false
fi
